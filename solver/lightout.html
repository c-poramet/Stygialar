<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Light Out Solver</title>

    <link rel="stylesheet" href="../styles.css">
    <style>
        .grid-container {
            display: inline-grid;
            gap: 4px;
            margin: 2rem 0;
            padding: 1rem;
            background-color: var(--primary-color);
            border-radius: 8px;
        }

        .grid-cell {
            width: 50px;
            height: 50px;
            border: 2px solid var(--accent-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .grid-cell:hover {
            border-color: var(--secondary-color);
            transform: scale(1.05);
        }

        .grid-cell.clickable {
            cursor: pointer;
        }

        .grid-cell.non-clickable {
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* CLI Styles */
        .terminal {
            font-family: 'Courier New', monospace;
            background-color: #000;
            color: var(--accent-color);
            padding: 1rem;
            border-radius: 8px;
            height: calc(100vh - 8rem);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .terminal-header {
            color: var(--secondary-color);
            margin-bottom: 1rem;
            font-weight: bold;
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 0.5rem;
        }

        .terminal-output {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 1rem;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .terminal-output::-webkit-scrollbar {
            width: 8px;
        }

        .terminal-output::-webkit-scrollbar-track {
            background: #111;
        }

        .terminal-output::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 4px;
        }

        .output-line {
            margin: 0.25rem 0;
        }

        .output-prompt {
            color: var(--secondary-color);
        }

        .output-command {
            color: #fff;
        }

        .output-result {
            color: var(--accent-color);
        }

        .output-error {
            color: #ff4444;
        }

        .output-success {
            color: #44ff44;
        }

        .output-info {
            color: #4488ff;
        }

        .terminal-input-container {
            display: flex;
            align-items: center;
            border-top: 1px solid var(--accent-color);
            padding-top: 0.5rem;
        }

        .terminal-prompt {
            color: var(--secondary-color);
            margin-right: 0.5rem;
            font-weight: bold;
        }

        .terminal-input {
            flex: 1;
            background: transparent;
            border: none;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            outline: none;
        }

        .autocomplete-suggestions {
            background: #222;
            border: 1px solid var(--accent-color);
            border-radius: 4px;
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            margin-bottom: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .suggestion-item {
            padding: 0.5rem;
            cursor: pointer;
            border-bottom: 1px solid #333;
        }

        .suggestion-item:hover,
        .suggestion-item.selected {
            background: var(--accent-color);
            color: #000;
        }

        .suggestion-command {
            font-weight: bold;
        }

        .suggestion-description {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-left: 1rem;
        }

        .input-wrapper {
            position: relative;
            flex: 1;
        }
    </style>
</head>
<body>
    <div class="main" id="main">
        <!-- <h1>Light Out Solver</h1> -->
        <div id="grid-display" style="display: flex; justify-content: center; align-items: center;"></div>
    </div>
    <div class="side">
        <div class="terminal">
            <div class="terminal-header">
                ╔═══════════════════════════════════════╗
                ║   LIGHT OUT PUZZLE SOLVER CLI v1.0   ║
                ╚═══════════════════════════════════════╝
            </div>
            <div class="terminal-output" id="terminal-output">
                <div class="output-line output-info">Welcome to Light Out Solver CLI!</div>
                <div class="output-line output-info">Type 'help' to see available commands.</div>
                <div class="output-line output-info">Use TAB for autocomplete and arrow keys to navigate history.</div>
                <div class="output-line">&nbsp;</div>
            </div>
            <div class="terminal-input-container">
                <span class="terminal-prompt">lightout></span>
                <div class="input-wrapper">
                    <div class="autocomplete-suggestions" id="autocomplete" style="display: none;"></div>
                    <input type="text" class="terminal-input" id="terminal-input" autocomplete="off" spellcheck="false">
                </div>
            </div>
        </div>
    </div>

    <script>
        // Puzzle state
        const puzzleState = {
            gridWidth: 5,
            gridHeight: 5,
            cellStates: null,
            maxStates: 2, // Number of states per cell (2 = on/off, 3 = off/dim/bright, etc.)
            stateConfig: null, // null = uniform, or array of max states per position
            manualSetMode: false,
            initialized: false
        };

        // CLI state
        const cliState = {
            history: [],
            historyIndex: -1,
            suggestions: [],
            selectedSuggestion: -1,
            awaitingInput: null, // For multi-step commands
            inputCallback: null
        };

        // Available commands
        const commands = {
            'help': {
                description: 'Show available commands',
                usage: 'help [command]',
                execute: cmdHelp
            },
            'setsize': {
                description: 'Set the grid size for the puzzle',
                usage: 'setsize <size> or setsize <width> <height>',
                execute: cmdSetSize
            },
            'manualset': {
                description: 'Enable manual cell state setting mode',
                usage: 'manualset [on|off]',
                execute: cmdManualSet
            },
            'config': {
                description: 'Configure puzzle properties',
                usage: 'config [uniform <states> | custom]',
                execute: cmdConfig
            },
            'clear': {
                description: 'Clear the terminal output',
                usage: 'clear',
                execute: cmdClear
            },
            'reset': {
                description: 'Reset the puzzle to initial state',
                usage: 'reset',
                execute: cmdReset
            },
            'show': {
                description: 'Show current puzzle configuration',
                usage: 'show',
                execute: cmdShow
            },
            'solve': {
                description: 'Solve the current puzzle configuration',
                usage: 'solve',
                execute: cmdSolve
            }
        };

        // DOM elements
        const terminalInput = document.getElementById('terminal-input');
        const terminalOutput = document.getElementById('terminal-output');
        const autocompleteDiv = document.getElementById('autocomplete');
        const gridDisplay = document.getElementById('grid-display');

        // Initialize
        terminalInput.focus();
        initializePuzzle();

        // Event listeners
        terminalInput.addEventListener('keydown', handleKeyDown);
        terminalInput.addEventListener('input', handleInput);

        function handleKeyDown(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                executeCommand();
            } else if (e.key === 'Tab') {
                e.preventDefault();
                handleTabComplete();
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (autocompleteDiv.style.display === 'block') {
                    navigateSuggestions(-1);
                } else {
                    navigateHistory(-1);
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (autocompleteDiv.style.display === 'block') {
                    navigateSuggestions(1);
                } else {
                    navigateHistory(1);
                }
            } else if (e.key === 'Escape') {
                autocompleteDiv.style.display = 'none';
                cliState.selectedSuggestion = -1;
            }
        }

        function handleInput(e) {
            const value = e.target.value;
            if (value.trim()) {
                updateSuggestions(value);
            } else {
                autocompleteDiv.style.display = 'none';
            }
        }

        function updateSuggestions(input) {
            const parts = input.trim().split(/\s+/);
            const firstWord = parts[0].toLowerCase();
            
            cliState.suggestions = [];

            if (parts.length === 1) {
                // Suggest commands
                for (const [cmd, info] of Object.entries(commands)) {
                    if (cmd.startsWith(firstWord)) {
                        cliState.suggestions.push({
                            text: cmd,
                            description: info.description,
                            type: 'command'
                        });
                    }
                }
            } else {
                // Command-specific suggestions
                const cmd = firstWord;
                const currentArg = parts[parts.length - 1];

                if (cmd === 'manualset' && parts.length === 2) {
                    ['on', 'off'].forEach(opt => {
                        if (opt.startsWith(currentArg.toLowerCase())) {
                            cliState.suggestions.push({
                                text: `${cmd} ${opt}`,
                                description: opt === 'on' ? 'Enable manual mode' : 'Disable manual mode',
                                type: 'argument'
                            });
                        }
                    });
                } else if (cmd === 'config' && parts.length === 2) {
                    ['uniform', 'custom'].forEach(opt => {
                        if (opt.startsWith(currentArg.toLowerCase())) {
                            cliState.suggestions.push({
                                text: `${cmd} ${opt}`,
                                description: opt === 'uniform' ? 'Same states for all cells' : 'Custom states per cell',
                                type: 'argument'
                            });
                        }
                    });
                } else if (cmd === 'help' && parts.length === 2) {
                    Object.keys(commands).forEach(c => {
                        if (c.startsWith(currentArg.toLowerCase())) {
                            cliState.suggestions.push({
                                text: `${cmd} ${c}`,
                                description: `Get help for ${c}`,
                                type: 'argument'
                            });
                        }
                    });
                }
            }

            if (cliState.suggestions.length > 0) {
                displaySuggestions();
            } else {
                autocompleteDiv.style.display = 'none';
            }
        }

        function displaySuggestions() {
            autocompleteDiv.innerHTML = '';
            cliState.suggestions.forEach((suggestion, index) => {
                const div = document.createElement('div');
                div.className = 'suggestion-item';
                if (index === cliState.selectedSuggestion) {
                    div.classList.add('selected');
                }
                div.innerHTML = `
                    <span class="suggestion-command">${suggestion.text}</span>
                    <span class="suggestion-description">${suggestion.description}</span>
                `;
                div.addEventListener('click', () => {
                    applySuggestion(index);
                });
                autocompleteDiv.appendChild(div);
            });
            autocompleteDiv.style.display = 'block';
            cliState.selectedSuggestion = -1;
        }

        function navigateSuggestions(direction) {
            if (cliState.suggestions.length === 0) return;

            cliState.selectedSuggestion += direction;
            if (cliState.selectedSuggestion < 0) {
                cliState.selectedSuggestion = cliState.suggestions.length - 1;
            } else if (cliState.selectedSuggestion >= cliState.suggestions.length) {
                cliState.selectedSuggestion = 0;
            }

            displaySuggestions();
        }

        function handleTabComplete() {
            if (cliState.suggestions.length > 0) {
                const index = cliState.selectedSuggestion >= 0 ? cliState.selectedSuggestion : 0;
                applySuggestion(index);
            }
        }

        function applySuggestion(index) {
            if (index >= 0 && index < cliState.suggestions.length) {
                terminalInput.value = cliState.suggestions[index].text;
                autocompleteDiv.style.display = 'none';
                cliState.selectedSuggestion = -1;
                terminalInput.focus();
            }
        }

        function navigateHistory(direction) {
            if (cliState.history.length === 0) return;

            if (cliState.historyIndex === -1) {
                cliState.historyIndex = cliState.history.length;
            }

            cliState.historyIndex += direction;
            
            if (cliState.historyIndex < 0) {
                cliState.historyIndex = 0;
            } else if (cliState.historyIndex >= cliState.history.length) {
                cliState.historyIndex = -1;
                terminalInput.value = '';
                return;
            }

            terminalInput.value = cliState.history[cliState.historyIndex];
        }

        function executeCommand() {
            const input = terminalInput.value.trim();
            
            if (!input) return;

            // Add to output
            addOutput(`<span class="output-prompt">lightout></span> <span class="output-command">${escapeHtml(input)}</span>`);

            // Check if we're in awaiting input mode
            if (cliState.awaitingInput && cliState.inputCallback) {
                const callback = cliState.inputCallback;
                cliState.awaitingInput = null;
                cliState.inputCallback = null;
                callback(input);
                terminalInput.value = '';
                return;
            }

            // Add to history
            if (cliState.history[cliState.history.length - 1] !== input) {
                cliState.history.push(input);
            }
            cliState.historyIndex = -1;

            // Parse and execute
            const parts = input.trim().split(/\s+/);
            const cmd = parts[0].toLowerCase();
            const args = parts.slice(1);

            if (commands[cmd]) {
                try {
                    commands[cmd].execute(args);
                } catch (error) {
                    addOutput(`<span class="output-error">Error: ${escapeHtml(error.message)}</span>`);
                }
            } else {
                addOutput(`<span class="output-error">Unknown command: ${escapeHtml(cmd)}. Type 'help' for available commands.</span>`);
            }

            terminalInput.value = '';
            autocompleteDiv.style.display = 'none';
        }

        // Command implementations
        function cmdHelp(args) {
            if (args.length > 0) {
                const cmd = args[0].toLowerCase();
                if (commands[cmd]) {
                    addOutput(`<span class="output-info">Command: ${cmd}</span>`);
                    addOutput(`<span class="output-result">Description: ${commands[cmd].description}</span>`);
                    addOutput(`<span class="output-result">Usage: ${commands[cmd].usage}</span>`);
                } else {
                    addOutput(`<span class="output-error">Unknown command: ${escapeHtml(cmd)}</span>`);
                }
            } else {
                addOutput('<span class="output-info">Available commands:</span>');
                for (const [cmd, info] of Object.entries(commands)) {
                    addOutput(`<span class="output-result">  ${cmd.padEnd(12)} - ${info.description}</span>`);
                }
                addOutput('&nbsp;');
                addOutput('<span class="output-info">Use "help &lt;command&gt;" for detailed information.</span>');
            }
        }

        function cmdSetSize(args) {
            if (args.length === 0) {
                addOutput('<span class="output-error">Usage: setsize &lt;size&gt; or setsize &lt;width&gt; &lt;height&gt;</span>');
                addOutput(`<span class="output-info">Current grid size: ${puzzleState.gridWidth}x${puzzleState.gridHeight}</span>`);
                return;
            }

            let width, height;

            if (args.length === 1) {
                // Square grid
                const size = parseInt(args[0]);
                if (isNaN(size) || size < 1 || size > 20) {
                    addOutput('<span class="output-error">Invalid size. Please enter a number between 1 and 20.</span>');
                    return;
                }
                width = height = size;
            } else {
                // Non-square grid
                width = parseInt(args[0]);
                height = parseInt(args[1]);
                
                if (isNaN(width) || isNaN(height)) {
                    addOutput('<span class="output-error">Invalid dimensions. Both width and height must be numbers.</span>');
                    return;
                }
                
                if (width < 1 || width > 20 || height < 1 || height > 20) {
                    addOutput('<span class="output-error">Invalid dimensions. Both width and height must be between 1 and 20.</span>');
                    return;
                }
            }

            puzzleState.gridWidth = width;
            puzzleState.gridHeight = height;
            initializePuzzle();
            addOutput(`<span class="output-success">Grid size set to ${width}x${height}</span>`);
            renderGrid();
        }

        function cmdManualSet(args) {
            if (args.length === 0) {
                puzzleState.manualSetMode = !puzzleState.manualSetMode;
            } else {
                const mode = args[0].toLowerCase();
                if (mode === 'on') {
                    puzzleState.manualSetMode = true;
                } else if (mode === 'off') {
                    puzzleState.manualSetMode = false;
                } else {
                    addOutput('<span class="output-error">Usage: manualset [on|off]</span>');
                    return;
                }
            }

            addOutput(`<span class="output-success">Manual set mode: ${puzzleState.manualSetMode ? 'ON' : 'OFF'}</span>`);
            if (puzzleState.manualSetMode) {
                addOutput('<span class="output-info">Click cells in the grid to toggle their state.</span>');
            }
            renderGrid();
        }

        function cmdConfig(args) {
            if (args.length === 0) {
                addOutput('<span class="output-error">Usage: config [uniform &lt;states&gt; | custom]</span>');
                addOutput('<span class="output-info">  uniform &lt;states&gt; - Set same number of states for all cells</span>');
                addOutput('<span class="output-info">  custom - Set different states for each cell position</span>');
                return;
            }

            const mode = args[0].toLowerCase();

            if (mode === 'uniform') {
                if (args.length < 2) {
                    addOutput('<span class="output-error">Usage: config uniform &lt;states&gt;</span>');
                    addOutput('<span class="output-info">Example: config uniform 3 (for off/dim/bright)</span>');
                    return;
                }

                const states = parseInt(args[1]);
                if (isNaN(states) || states < 2 || states > 10) {
                    addOutput('<span class="output-error">Invalid states. Please enter a number between 2 and 10.</span>');
                    return;
                }

                puzzleState.maxStates = states;
                puzzleState.stateConfig = null; // Uniform configuration
                initializePuzzle();
                addOutput(`<span class="output-success">Configured for uniform ${states} states per cell.</span>`);
                renderGrid();

            } else if (mode === 'custom') {
                addOutput('<span class="output-info">Configuring custom state counts per cell...</span>');
                addOutput(`<span class="output-info">Enter states for each row (${puzzleState.gridWidth} values per row).</span>`);
                addOutput('<span class="output-info">Values should be between 2 and 10, separated by spaces.</span>');
                
                const customConfig = [];
                let currentRow = 0;

                const processRow = (input) => {
                    const values = input.trim().split(/\s+/).map(v => parseInt(v));
                    
                    if (values.length !== puzzleState.gridWidth) {
                        addOutput(`<span class="output-error">Expected ${puzzleState.gridWidth} values, got ${values.length}. Try again:</span>`);
                        waitForInput(processRow);
                        return;
                    }

                    if (values.some(v => isNaN(v) || v < 2 || v > 10)) {
                        addOutput('<span class="output-error">All values must be between 2 and 10. Try again:</span>');
                        waitForInput(processRow);
                        return;
                    }

                    customConfig.push(...values);
                    currentRow++;

                    if (currentRow < puzzleState.gridHeight) {
                        addOutput(`<span class="output-info">Row ${currentRow + 1}:</span>`);
                        waitForInput(processRow);
                    } else {
                        puzzleState.stateConfig = customConfig;
                        puzzleState.maxStates = Math.max(...customConfig);
                        initializePuzzle();
                        addOutput('<span class="output-success">Custom configuration applied!</span>');
                        renderGrid();
                    }
                };

                addOutput(`<span class="output-info">Row 1:</span>`);
                waitForInput(processRow);

            } else {
                addOutput('<span class="output-error">Unknown config mode. Use "uniform" or "custom".</span>');
            }
        }

        function cmdClear(args) {
            terminalOutput.innerHTML = '';
        }

        function cmdReset(args) {
            initializePuzzle();
            addOutput('<span class="output-success">Puzzle reset to initial state.</span>');
            renderGrid();
        }

        function cmdShow(args) {
            addOutput('<span class="output-info">Current Puzzle Configuration:</span>');
            addOutput(`<span class="output-result">  Grid Size: ${puzzleState.gridWidth}x${puzzleState.gridHeight}</span>`);
            
            if (puzzleState.stateConfig === null) {
                addOutput(`<span class="output-result">  States: ${puzzleState.maxStates} (uniform)</span>`);
            } else {
                addOutput(`<span class="output-result">  States: Custom configuration</span>`);
                for (let i = 0; i < puzzleState.gridHeight; i++) {
                    const row = puzzleState.stateConfig.slice(i * puzzleState.gridWidth, (i + 1) * puzzleState.gridWidth);
                    addOutput(`<span class="output-result">    Row ${i + 1}: ${row.join(' ')}</span>`);
                }
            }
            
            addOutput(`<span class="output-result">  Manual Mode: ${puzzleState.manualSetMode ? 'ON' : 'OFF'}</span>`);
            
            addOutput('&nbsp;');
            addOutput('<span class="output-info">Current State:</span>');
            for (let i = 0; i < puzzleState.gridHeight; i++) {
                const row = puzzleState.cellStates.slice(i * puzzleState.gridWidth, (i + 1) * puzzleState.gridWidth);
                addOutput(`<span class="output-result">  ${row.join(' ')}</span>`);
            }
        }

        function cmdSolve(args) {
            addOutput('<span class="output-info">Solving puzzle...</span>');
            addOutput('<span class="output-error">Solver algorithm not yet implemented.</span>');
            addOutput('<span class="output-info">This feature will use Gaussian elimination over GF(n) to find solution.</span>');
        }

        // Helper functions
        function waitForInput(callback) {
            cliState.awaitingInput = true;
            cliState.inputCallback = callback;
        }

        function addOutput(html) {
            const div = document.createElement('div');
            div.className = 'output-line';
            div.innerHTML = html;
            terminalOutput.appendChild(div);
            terminalOutput.scrollTop = terminalOutput.scrollHeight;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function initializePuzzle() {
            const totalCells = puzzleState.gridWidth * puzzleState.gridHeight;
            puzzleState.cellStates = new Array(totalCells).fill(0);
            puzzleState.initialized = true;
        }

        function renderGrid() {
            gridDisplay.innerHTML = '';
            
            const container = document.createElement('div');
            container.className = 'grid-container';
            container.style.gridTemplateColumns = `repeat(${puzzleState.gridWidth}, 50px)`;

            for (let i = 0; i < puzzleState.gridWidth * puzzleState.gridHeight; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                
                if (puzzleState.manualSetMode) {
                    cell.classList.add('clickable');
                    cell.addEventListener('click', () => toggleCell(i));
                } else {
                    cell.classList.add('non-clickable');
                }

                const maxState = puzzleState.stateConfig ? puzzleState.stateConfig[i] : puzzleState.maxStates;
                const state = puzzleState.cellStates[i];
                
                // Color based on state
                const hue = (state / (maxState - 1)) * 120; // 0 = red, 120 = green
                const lightness = 20 + (state / (maxState - 1)) * 60;
                cell.style.backgroundColor = `hsl(${hue}, 80%, ${lightness}%)`;
                
                if (maxState > 2) {
                    cell.textContent = state;
                }

                container.appendChild(cell);
            }

            gridDisplay.appendChild(container);
        }

        function toggleCell(index) {
            if (!puzzleState.manualSetMode) return;

            const maxState = puzzleState.stateConfig ? puzzleState.stateConfig[index] : puzzleState.maxStates;
            puzzleState.cellStates[index] = (puzzleState.cellStates[index] + 1) % maxState;
            renderGrid();
        }

        // Initial render
        renderGrid();
    </script>
</body>
</html>